import asyncio
from django.core.management.base import BaseCommand
from django.conf import settings
from django.template import Context
from telegram import Bot, Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import ApplicationBuilder, MessageHandler, filters, CallbackContext, ContextTypes, CommandHandler, \
    CallbackQueryHandler
from asgiref.sync import sync_to_async
from telegram_bot_calendar import DetailedTelegramCalendar, LSTEP

from bot.management.commands.dep.commands import check_records_user
from bot.models import Message, Profile, Rent



# Состояния пользователя
STATE_MAIN_MENU = "MAIN_MENU"

STATE_BOOK = "BOOK"
STATE_BOOK_CHOOSE_PLANE = "BOOK_CHOOSE_PLANE"
STATE_BOOK_CHOOSE_DATE_ON_FLY = "BOOK_CHOOSE_TIME_ON_FLY"

STATE_SETTINGS = "SETTINGS"

STATE_CHECK_RESERVATIONS = "CHECK_RESERVATIONS"
STATE_RESERVATION_CNAHGE_DELETE = "RESERVATION"



def log_error(f):
    def inner(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except Exception as e:
            error_message = f'Error: {e}'
            print(error_message)
            raise e

    return inner


@log_error
async def do_echo(update: Update, context: CallbackContext):
    chat_id = update.message.chat_id
    text = update.message.text

    p, _ = await sync_to_async(Profile.objects.get_or_create)(
        external_id=chat_id,
        defaults={'name': update.message.from_user.username}
    )

    message_instance = Message(
        profile=p,
        text=text,
    )
    await sync_to_async(message_instance.save)()

    reply_text = "Your ID = {}\n\n{}".format(chat_id, text)
    await update.message.reply_text(text=reply_text)





async def start_command(update: Update, context: CallbackContext) -> None:
    await show_main_menu(update, context)


async def show_main_menu(update: Update, context: CallbackContext) -> None:
    # Устанавливаем текущее состояние в главное меню
    context.user_data['state'] = STATE_MAIN_MENU

    # Отображаем главное меню
    reply_keyboard = [
        ['Забронировать', 'Настройки'],
        ['Проверить активные брони']
    ]
    await update.message.reply_text(
        "Главное меню: Выберите операцию",
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True)
    )


async def handle_book(update: Update, context: CallbackContext) -> None:
    context.user_data['state'] = STATE_BOOK  # Обновляем состояние
    await update.message.reply_text(
        " Вы выбрали 'Забронировать'. Процесс бронирования начат. \n Выберите самолёт \n Нажмите 'Назад', чтобы вернуться.",
        reply_markup=ReplyKeyboardMarkup([['Самолёт 1','Самолёт 2',],['Назад']], resize_keyboard=True,)
    )

async def handle_book_choose_plane(update: Update, context: CallbackContext) -> None:

    chosen_plane = update.message.text
    context.user_data['chosen_plane'] = chosen_plane
    context.user_data['state'] = STATE_BOOK_CHOOSE_PLANE

    await update.message.reply_text(
        f"Вы выбрали {chosen_plane}. Выбор сохранен.\n"
        "Теперь выбирите дату полёта",
        reply_markup=ReplyKeyboardMarkup([['Назад']], resize_keyboard=True)
    )




async def handle_settings(update: Update, context: CallbackContext) -> None:
    context.user_data['state'] = STATE_SETTINGS  # Обновляем состояние
    await update.message.reply_text(
        "Вы выбрали 'Настройки'. Нажмите 'Назад', чтобы вернуться.",
        reply_markup=ReplyKeyboardMarkup([['Назад']], resize_keyboard=True)
    )


async def handle_check_reservations(update: Update, context: CallbackContext) -> None:
    context.user_data['state'] = STATE_CHECK_RESERVATIONS  # Обновляем состояние
    # await update.message.reply_text(
    #     "Здесь проверяются активные брони. Нажмите 'Назад', чтобы вернуться.",
    #     reply_markup=ReplyKeyboardMarkup([['Назад']], resize_keyboard=True)
    # )
    await check_records_user(update, context)


async def handle_back(update: Update, context: CallbackContext) -> None:
    # Проверяем предыдущее состояние и возвращаем на соответствующий экран
    previous_state = context.user_data.get('state')

    if previous_state == STATE_BOOK or previous_state == STATE_SETTINGS or previous_state == STATE_CHECK_RESERVATIONS:
        await show_main_menu(update, context)


    elif previous_state == STATE_BOOK_CHOOSE_PLANE:
        await handle_book(update, context)
    elif previous_state == STATE_BOOK_CHOOSE_DATE_ON_FLY:
        await handle_book_choose_plane(update, context)


    else:
        await update.message.reply_text("Вы уже в главном меню.")




user_dates = {}

# Command to display the calendar
async def calendar_command(update: Update, context: CallbackContext) -> None:
    """Sends an inline calendar for the user to select a date."""
    # Initialize the calendar with a unique calendar_id to avoid conflicts
    calendar, step = DetailedTelegramCalendar(calendar_id='calendar').build()
    await update.message.reply_text(
        f"Select {LSTEP[step]}",
        reply_markup=calendar
    )

# Handler to process calendar selection
async def handle_calendar_selection(update: Update, context: CallbackContext) -> None:
    """Processes the calendar selection and stores the selected date."""
    query = update.callback_query
    await query.answer()

    # Process the callback data to get the result, new keyboard, and current step
    result, key, step = DetailedTelegramCalendar(calendar_id='calendar').process(query.data)
    if not result and key:
        # Continue with the next step in the calendar selection
        await query.edit_message_text(
            f"Select {LSTEP[step]}",
            reply_markup=key
        )
    elif result:
        # Save the selected date in `user_dates` dictionary with the user's ID as the key
        user_id = query.from_user.id
        user_dates[user_id] = result
        await query.edit_message_text(
            f"You selected {result}. Date saved!"
        )




class Command(BaseCommand):
    help = "Запуск Telegram бота "

    def handle(self, *args, **options):
        application = ApplicationBuilder().token(settings.TOKEN).build()

        application.add_handler(CommandHandler("start", start_command))

        # Обработчики для каждого состояния
        application.add_handler(MessageHandler(filters.TEXT & filters.Regex("^Забронировать$"), handle_book))
        application.add_handler(MessageHandler(filters.TEXT & filters.Regex("^Самолёт 1|Самолёт 2$"), handle_book_choose_plane))



        application.add_handler(MessageHandler(filters.TEXT & filters.Regex("^Настройки$"), handle_settings))
        application.add_handler(
            MessageHandler(filters.TEXT & filters.Regex("^Проверить активные брони$"), handle_check_reservations))

        # Обработчик для кнопки "Назад"
        application.add_handler(MessageHandler(filters.TEXT & filters.Regex("^Назад$"), handle_back))

        application.add_handler(CommandHandler("calendar", calendar_command))
        # Заменяем pattern на более точный
        application.add_handler(CallbackQueryHandler(handle_calendar_selection, pattern="^calendar"))

        application.run_polling()
